--- 
title: "Environmental rasters for South Australia"
author:
- Nigel Willoughby
- Trevor Hobbs
- Joel Allen
- Simeon Zylinski
- Andrew West
- Department for Environment and Water
date: "`r format(Sys.time(), '%A, %d %B, %Y. %H:%M')`"
link-citations: yes
bibliography:
-  "`r fs::path('H:', 'data', 'bib', 'refs.bib')`"
-  "`r here::here('report', 'packages.bib')`"
always_allow_html: yes
description: R code to generate environmental rasters
---

```{r setup, echo = FALSE, warning = FALSE, error = FALSE, message = FALSE}

  repo_link <- paste0("https://github.com/Acanthiza/", basename(here::here()))

  #------Bibliography-------

  ## generic bib----
  bib_file <- fs::path("H:", "data", "bib", "refs.bib")
  
  ## specific bib-------
  out_file <- here::here("report", "bib_style.csl")

  if(!file.exists(out_file)) {
    
    url <- "https://raw.githubusercontent.com/citation-style-language/styles/master/emu-austral-ornithology.csl"
    download.file(url, here::here("report", "bib_style.csl"))
    
  }

  unlink(here::here("report", "packages.bib"))
  
  knitr::write_bib(x = packages
                   , file = here::here("report", "packages.bib")
                   )
  
  #--------knitr options--------
  
  knitr::opts_knit$set(eval.after = "fig.cap" 
                       , output_dir = here::here("report")
                       , progress = FALSE
                       )

  
  knitr::opts_chunk$set(echo = FALSE
                        , warning = FALSE
                        , error = FALSE
                        , message = FALSE
                        , tidy = TRUE
                        #, tidy.opts = list(comment = FALSE)
                        #, dpi = 300
                        #, fig.width = 7
                        )
  
  # kableExtra options --------
  
  bs_style <- c("striped")

  options(kable_styling_bootstrap_options = bs_style)

  #sa state outline
  sa <- sfarrow::st_read_parquet(fs::path("H:"
                                          , "data"
                                          , "vector"
                                          , "sa.parquet"
                                          )
                                 ) %>%
    sf::st_transform(crs = settings$epsg_proj) %>%
    sf::st_make_valid()
  
  
  #--------options-------

  options(knitr.kable.NA = ""
          , knitr.duplicate.label = "allow"
          )
  
  # tmap mode - overrides "view" set in 0010_setup
  tmap::tmap_mode("view")
    
  ##or set manually
  if(FALSE) use_tmap_mode <- "plot"
  
  terra::terraOptions(progress = 0) #suppress progress bars
  

```

# Aim {-}

This goal of `envRas` is to create analysis ready raster data for a specific area.

<!--chapter:end:index.Rmd-->

# Introduction

## Background

This report documents the inputs, workflow and outputs of a scripted process to create analysis ready raster data. As an automated workflow, it can be applied to different areas, producing new spatial information relevant to those areas. In this report, an example area is used: "`r envFunc::vec_to_sentence(settings$level)`" but the workflow is used up to an extent greater than all of South Australia.

## General methods

### Area of interest

Figure \@ref(fig:aoimap) shows the area of interest for this `r envFunc::vec_to_sentence(settings$level)` example area, in the context of the rest of the South Australia.

<caption>(#fig:aoimap) Figure \@ref(fig:aoimap) `r envFunc::vec_to_sentence(settings$level)`</caption>

```{r aoimap, results = "asis"}

  # html cross referencing issue:
    # https://github.com/glin/reactable/issues/15#issuecomment-560112306

  use_bbox <- settings$boundary %>%
    sf::st_buffer(100000) %>%
    sf::st_bbox()

  tm_shape(sa
           , bbox = use_bbox
           ) +
    tm_borders() +
  tm_shape(settings$boundary) +
    tm_borders(col = "red")

```


### Scripting

The data analysis and report writing were done in via a scripted workflow using the programs 'R' and 'R-studio'. [R](https://www.r-project.org/) `r cite_package("base")` is a free software environment for statistical computing and graphics. R can be extended via a range of packages that enable specific tasks or analyses. The packages used to produce this report are listed in Appendix Table \@ref(tab:packages). [R-studio](https://www.rstudio.com/) provides a range of user-friendly features to facilitate interaction with R.

All code is stored in a version control system at [`r basename(here::here())`](%60r%20repo_link%60) (repository is currently private, so link will probably not work).

Several packages were created to facilitate this workflow:

* `r bib2df::bib2df(here::here("report", "packages.bib")) %>% dplyr::filter(grepl("^R-env", BIBTEXKEY)) %>% dplyr::select(BIBTEXKEY,TITLE) %>% dplyr::pull(TITLE) %>% paste0(collapse = "\n* ")`


<!--chapter:end:0010_introduction.Rmd-->


# Satellite cubes

Digital Earth Australia [DEA](https://www.dea.ga.gov.au/) provides earth observation data for Australia. DEA data was accessed via a workflow that:

* finds features available for an area and timeframe
* creates an image collection from available features
* defines a [regular cube](https://e-sensing.github.io/sitsbook/earth-observation-data-cubes.html#regular-image-data-cubes) structure
* create a cloud mask
* merge the image collection into the parameters defined by the regular cube, taking into account the cloud mask

## Example: building a single seasonal image

The following example finds and processes Landsat 8 data to generate median Normalized Difference Vegetation Index ([NDVI](https://www.usgs.gov/landsat-missions/landsat-normalized-difference-vegetation-index)) for the `r settings$name` example area in summer 2019/2020.

Note that the `envRas` project makes use of the `envRaster` package `r cite_package("envRaster")` to abstract all these steps into the single function `get_sat_data`. 

### Find images

Features available within DEA data were found using [DEAâ€™s SpatioTemporal Asset Catalogue (STAC) metadata](https://knowledge.dea.ga.gov.au/guides/setup/gis/stac/). [STAC](https://stacspec.org/en) is a specification that provides a common language to describe geospatial information so it can more easily be discovered. The `rstac` package `r `cite_package("rstac")` was used to find the images available for each DEA collection specified for an area of interest.

A bounding box is required to define the area for `rstac` to search. In this case, the coordinate systems for the bounding box should be in WGS84 decimal degrees ([epsg: `4326`](https://epsg.io/4326)).

```{r stacExample, include = TRUE, echo = TRUE, cache = TRUE}

  start_date <- "2019-12-01"
  end_date <- "2020-02-29"
  
  base_grid <- terra::rast(extent = settings$boundary
                           , crs = terra::crs(settings$boundary)
                           , res = c(settings$sat_res, settings$sat_res)
                           , vals = 1
                           )

  make_sat_cube(base_grid
                , start_date = start_date
                , end_date = end_date
                , season = "summer"
                , out_dir = here::here("report", "out")
                , collections = c("ga_ls8c_ard_3", "ga_ls9c_ard_3")
                , period = "P3M"
                , layers = NULL
                , indices = list("ndvi" = c("nir", "red"))
                , mask = list(band = "oa_fmask", mask = c(2, 3))
                , chunks = c(1, 1)
                , chunk_dir = fs::path(Sys.getenv("TMPDIR"), "sat_cube_temp")
                , chunk_prefix = "tile_"
                , sleep = 60
                , attempts = 1
                , property_filter = \(x) {x[["eo:cloud_cover"]] < 10}
                )

```

Figure \@ref(fig:examplePlot) shows the Normalized Difference Vegetation Index ([NDVI](https://www.usgs.gov/landsat-missions/landsat-normalized-difference-vegetation-index))) result for the example area and timeframe.

```{r examplePlot, fig.cap = "NDVI result for the example area"}
  
  terra::plot(terra::rast(here::here("report"
                                     , "out"
                                     , paste0("ndvi__summer__"
                                              , start_date
                                              , ".tif"
                                              )
                                     )
                          )
              )

```

## Satellite seasonal cube

```{r satSeasonalCubeData}

  sat_seas_cube_dir <- fs::path("I:"
                                , "sa_ibrasub_xn______0"
                                , "P3M__30"
                                , "DEA__ga_ls8c_ard_3--ga_ls9c_ard_3"
                                )

  sat_seas_cube <- name_env_tif(sat_seas_cube_dir
                           , parse = TRUE
                           ) %>%
    dplyr::filter(source == "DEA") %>%
    dplyr::mutate(start_date = as.Date(start_date))

  sat_layers <- sat_seas_cube %>%
    dplyr::select(source, collection, layer) %>%
    dplyr::distinct()

  sat_seasons <- settings$epochs %>%
    tidyr::unnest(cols = c(years)) %>%
    dplyr::rename(year = years) %>%
    dplyr::left_join(settings$seasons$seasons) %>%
    dplyr::inner_join(sat_seas_cube) %>%
    dplyr::select(year, epoch, season, start_date, end_date) %>%
    dplyr::distinct()

```

Table \@ref(tab:satCollectionTab) shows the collection and layers prepared from DEA data for each of the seasons in Table \@ref(tab:satSeasonsTab). This created a regular cube of `r nrow(sat_seas_cube)` files made up of `r nrow(sat_layers)` layers with seasonal data for each of `r nrow(sat_seasons)` seasons. This seasonal cube had the following parameters:

* start date: `r min(sat_seasons$start_date)`
* end date: `r max(sat_seasons$end_date)`
* period (in [ISO-8601 duration](https://www.digi.com/resources/documentation/digidocs/90001488-13/reference/r_iso_8601_duration_format.htm) format): `r settings$period`
* x and y distance: `r settings$sat_res` m
* seasons: `r sat_seasons$season %>% unique %>% vec_to_sentence`
* December data summarized into following year. e.g. December 2019 data will appear in the summer 2020 layer

[Appendix][appendices] Table \@ref(tab:satSeasCubeApp) lists details for each of the existing layers in the seasonal cube.

<br>

```{r satCollectionTab}  
  
  knitr::kable(sat_layers %>%
                 dplyr::mutate(collection = gsub("--", " and ", collection))
               , caption = "DEA collections and layers prepared by envRas"
               )

```

<br>

```{r satSeasonsTab}

  knitr::kable(sat_seasons
               , caption = "Start and end dates defining seasons for preparing DEA layers"
               )

```

## Satellite epoch cube

```{r satEpochCubeData}

  sat_epoch_cube_dir <- if(dir.exists(gsub("P3M", "P10Y", settings$sat_seas_cube_dir))) {
    
    fs::dir_ls(gsub("P3M", "P10Y", settings$sat_seas_cube_dir))
    
  } else {
  
    fs::path("H:"
             , "data"
             , "raster"
             , "aligned"
             , "sa_ibrasub_xn____0__30"
             )
    
  }

  sat_epoch_cube <- terra::rast(sat_epoch_cube_dir)

  sat_epoch_cube_data <- tibble::enframe(terra::sources(sat_epoch_cube), name = NULL, value = "path") %>%
    name_env_tif(parse = TRUE) %>%
    dplyr::mutate(values = purrr::map(path, \(x) terra::values(terra::rast(x)))
                  , data = purrr::map(values, \(x) quibble(x))
                  , use_name = paste0(layer, " ", season)
                  , layerid = gsub("[[:punct:]]", "", layer)
                  ) %>%
    tidyr::unnest(cols = c(data))
  
  names(sat_epoch_cube) <- sat_epoch_cube_data$use_name

```

A cube with `r settings$epoch_period`-year epochs, was then generated from the [seasonal cube]. The epoch cube had the same parameters as the seasonal cube, except that the period was `P10Y` instead of `P3M`. Note that, say, summer, in the `r settings$epoch_period`-year epoch cube took the median values for each summer image in the seasonl cube.

Table \@ref(tab:satEpochTab) shows a summary of the layers and layer values.

```{r satEpochTab}

  knitr::kable(sat_epoch_cube_data %>%
          dplyr::mutate(across(where(is.numeric), ~round(.x, 2))
                        , iqr = paste0(q25
                                     , " to "
                                     , q75
                                     )
                        ) %>%
          dplyr::select(layer
                        , season
                        , median = q50
                        #, sd
                        , `inter-quartile range` = iqr
                        ) %>%
          janitor::remove_empty(which = "cols")
        , caption = paste0("Summary of "
                           , unique(sat_epoch_cube_data$source)
                           , " (collection "
                           , unique(sat_epoch_cube_data$collection)
                           , ") layers for the "
                           , settings$name
                           , " example area"
                           )
        , align = "llrr"
        )

```

```{r satEpochRmd, eval = do_sat_summary, include = FALSE}

  sat_layers <- unique(sat_epoch_cube_data$layerid)

  sat_layer_rmd = NULL
  
  for (i in sat_layers) {
    
    this_layer <- i
    
    sat_layer_rmd = c(sat_layer_rmd
                      , knitr::knit_expand(here::here("report", "child", "sat_layer_rmd.Rmd"))
                      )
    
  }
  
```

`r if(do_sat_summary) paste(knitr::knit(text = sat_layer_rmd), collapse = '\n')`

<!--chapter:end:0020_sat.Rmd-->


# Climate cubes

ANUClimate 2.0 [@RN4594] is available from the National Computing Infrastructure ([NCI](https://nci.org.au/)) via their [THREDDS](https://docs.unidata.ucar.edu/tds/4.6/adminguide/) service [@RN4593].

NCI data was accessed via a workflow that:

* lists files for each season using the naming structure in the THREDDS service
    + each season had three files, one for each month in the season
* created a connection to each of those files
* subset the data to the desired geographic extent
* reduced the time axis to a single pixel for that season (min, mean, or max, depending on climate variable)
* adjusted the result to a grid in the desired output coordinate reference system
* saved the result locally

## Example

There is no STAC specification for the ANUClimate data available from the NCI. Instead, a series of filenames are built up using a pattern. Each file is the monthly (or daily are also available) climate data for all of Australia at roughly 1 km grid size. Each file is then queried for the geographic subset required.

As per the `get_sat_data`, there is an equivalent `get_cli_data` function in the `envRaster` package that abstracts many of the steps to download a climate cube.

```{r cliExampleFiles}

  cli_example_files <- files %>%
    dplyr::filter(start_date == as.Date(start_date)) %>%
    dplyr::mutate(out_file = here::here("report", "out", "cli_example.tif"))
  
  cli_example_files$data[[1]]
  
```

Three files representing monthly rainfall for the summer of 2014 (December 2013 to February 2014).

```{r cliExampleGet, cache = TRUE}
  
  purrr::pwalk(list(cli_example_files$data
                    , cli_example_files$out_file
                    , cli_example_files$func
                    , cli_example_files$scale
                    , cli_example_files$offset
                    )
               , get_cli_data
               , base = settings$base
               )
  
```

The `get_cli_data` function does the work of saving the resulting cube to the file specified in `cli_examples_files` object `r cli_example_files$out_file`. That example raster can be seen in Figure \@ref(fig:cliExampleMap).

```{r cliExampleMap, fig.cap = "Summer rain result from the call to `get_cli_data`"}

  plot(terra::rast(cli_example_files$out_file))

```

## Climate seasonal cube

```{r cliSeasonalCubeData}

  cli_seas_cube_dir <- fs::path("H:"
                                , "data"
                                , 'raster'
                                , "cube__P3M"
                                , "NCI__ANUClimate__sa_ibrasub_xn____0"
                                )

  cli_seas_cube <- parse_env_tif(cli_seas_cube_dir
                           , parse = TRUE
                           ) %>%
    dplyr::filter(source == "NCI") %>%
    dplyr::mutate(start_date = as.Date(start_date))

  cli_layers <- cli_seas_cube %>%
    dplyr::select(source, collection, band) %>%
    dplyr::distinct()

  cli_seasons <- settings$epochs %>%
    tidyr::unnest(cols = c(years)) %>%
    dplyr::rename(year = years) %>%
    dplyr::left_join(settings$seasons$seasons) %>%
    dplyr::inner_join(cli_seas_cube) %>%
    dplyr::select(year, epoch, season, start_date, end_date) %>%
    dplyr::distinct()

```

Table \@ref(tab:cliCollectionTab) shows the collection and layers prepared from NCI data for each of the seasons in Table \@ref(tab:cliSeasonsTab). This created a regular cube of `r nrow(cli_seas_cube)` files made up of `r nrow(cli_layers)` layers with seasonal data for each of `r nrow(cli_seasons)` seasons. This seasonal cube had the following parameters:

* start date: `r min(cli_seasons$start_date)`
* end date: `r max(cli_seasons$end_date)`
* period (in [ISO-8601 duration](https://www.digi.com/resources/documentation/digidocs/90001488-13/reference/r_iso_8601_duration_format.htm) format): `r settings$period`
* x and y distance: `r settings$cli_res` m
* seasons: `r cli_seasons$season %>% unique %>% vec_to_sentence`
* December data summarized into following year. e.g. December 2019 data will appear in the summer 2020 layer

[Appendix][appendices] Table \@ref(tab:cliSeasCubeApp) lists details for each of the existing layers in the seasonal cube.

<br>

```{r cliCollectionTab}  
  
  knitr::kable(cli_layers %>%
                      dplyr::mutate(collection = gsub("--", " and ", collection))
                    , caption = "NCI collections and layers prepared by envRas"
                    )

```

<br>

```{r cliSeasonsTab}

  knitr::kable(cli_seasons
                    , caption = "Start and end dates defining seasons for preparing NCI layers"
                    )

```

## Climate epoch cube

```{r cliEpochCubeData}

  cli_epoch_cube_dir <- if(dir.exists(gsub("P3M", "P10Y", settings$cli_seas_cube_dir))) {
    
    fs::dir_ls(gsub("P3M", "P10Y", settings$cli_seas_cube_dir))
    
  } else {
  
    fs::path("H:"
             , "data"
             , "raster"
             , "aligned"
             , "sa_ibrasub_xn____0__90"
             )
    
  }

  cli_epoch_cube <- terra::rast(fs::dir_ls(cli_epoch_cube_dir, regexp = "tif$"))

  cli_epoch_cube_data <- tibble::enframe(terra::sources(cli_epoch_cube), name = NULL, value = "path") %>%
    name_env_tif(parse = TRUE) %>%
    dplyr::mutate(values = purrr::map(path, \(x) terra::values(terra::rast(x)))
                  , data = purrr::map(values, \(x) quibble(x, na.rm = TRUE))
                  , use_name = paste0(layer, " ", season)
                  , layerid = gsub("[[:punct:]]", "", layer)
                  ) %>%
    tidyr::unnest(cols = c(data))
  
  names(cli_epoch_cube) <- cli_epoch_cube_data$use_name

```

A cube with `r settings$epoch_period`-year epochs, was then generated from the [seasonal cube]. The epoch cube had the same parameters as the seasonal cube, except that the period was `P10Y` instead of `P3M`. Note that, say, summer, in the `r settings$epoch_period`-year epoch cube took the median values for each summer image in the seasonl cube.

Table \@ref(tab:cliEpochTab) shows a summary of the layers and layer values.

```{r cliEpochTab}

  knitr::kable(cli_epoch_cube_data %>%
          dplyr::mutate(across(where(is.numeric), ~round(.x, 2))
                        , iqr = paste0(q25
                                     , " to "
                                     , q75
                                     )
                        ) %>%
          dplyr::select(layer
                        , season
                        , median = q50
                        #, sd
                        , `inter-quartile range` = iqr
                        ) %>%
          janitor::remove_empty(which = "cols")
        , caption = paste0("Summary of "
                           , unique(cli_epoch_cube_data$source)
                           , " (collection "
                           , unique(cli_epoch_cube_data$collection)
                           , ") layers for the "
                           , settings$name
                           , " example area"
                           )
        )

```

```{r cliEpochRmd, eval = do_cli_summary, include = FALSE}

  cli_layers <- unique(cli_epoch_cube_data$layerid)

  cli_layer_rmd = NULL
  
  for (i in cli_layers) {
    
    this_layer <- i
    
    cli_layer_rmd = c(cli_layer_rmd
                      , knitr::knit_expand(here::here("report", "child", "cli_layer_rmd.Rmd"))
                      )
    
  }
  
```

`r if(do_cli_summary) paste(knitr::knit(text = cli_layer_rmd), collapse = '\n')`

<!--chapter:end:0030_cli.Rmd-->


# References {-}

<div id="refs"></div>

<!--chapter:end:0090_references.Rmd-->


# Appendices {-}

## Packages

```{r packages}

  knitr::kable(tibble(package = packages) %>%
                      dplyr::mutate(citation = purrr::map_chr(package
                                                              , cite_package
                                                              , brack = FALSE
                                                              )
                                    ) %>%
                      dplyr::left_join(as_tibble(devtools::session_info(include_base = TRUE)$packages)) %>%
                      dplyr::select(package, citation, loadedversion, date
                                    , source
                                    ) %>% 
                      dplyr::mutate(source = case_when(grepl("Github", source) ~ "Github"
                                                       , TRUE ~ source
                                                       )
                                    )
                    , caption = paste0("R "
                                       , cite_package("base")
                                       , " packages used in the production of this report"
                                       )
                    )

```

## Satellite seasonal cube

```{r satSeasCubeApp}

  get_att <- function(desc, location, col) {

    extract_col <- function(desc, location, col) {
      
      desc[[location]][[col]]
      
    }
    
    safe_extract_col <- purrr::safely(extract_col)
    
    res <- safe_extract_col(desc, location, col)
    
    if(!is.null(res$result)) res$result else NA
    
  }

  sat_seas_cube_details <- sat_seas_cube %>%
    dplyr::mutate(desc = purrr::map(path, \(x) jsonlite::fromJSON(terra::describe(x, options = "json")))
                  , scale = purrr::map_dbl(desc, \(x) get_att(x, "bands", "scale"))
                  , offset = purrr::map_dbl(desc, \(x) get_att(x, "bands", "offset"))
                  , type = purrr::map_chr(desc, \(x) get_att(x, "bands", "type"))
                  , no_data = purrr::map_dbl(desc, \(x) get_att(x, "bands", "noDataValue"))
                  , epsg = purrr::map_dbl(desc, \(x) get_att(x, "stac", "proj:epsg"))
                  )

  sat_seas_cube_details %>%
    dplyr::select(period, res, layer, season, start_date, scale, offset, type, no_data, epsg) %>%
    knitr::kable(caption = paste0("Satellite seasonal cube data as at: ", format(Sys.Date(), "%d-%B-%Y")))

```

## Satellite epoch cube

```{r seasonalCubeTab}

  sat_epoch_cube_data %>%
    dplyr::mutate(desc = purrr::map(path, \(x) jsonlite::fromJSON(terra::describe(x, options = "json")))
                  , scale = purrr::map_dbl(desc, \(x) get_att(x, "bands", "scale"))
                  , offset = purrr::map_dbl(desc, \(x) get_att(x, "bands", "offset"))
                  , type = purrr::map_chr(desc, \(x) get_att(x, "bands", "type"))
                  , no_data = purrr::map_dbl(desc, \(x) get_att(x, "bands", "noDataValue"))
                  , epsg = purrr::map_dbl(desc, \(x) get_att(x, "stac", "`proj:epsg`"))
                  ) %>%
    dplyr::select(period, res, layer, season, start_date, scale, offset, type, no_data) %>%
    knitr::kable(caption = paste0("Satellite seaonal epoch cube data as at: "
                                       , format(Sys.Date()
                                                , "%d-%B-%Y"
                                                )
                                       )
                      )

```

<!--chapter:end:0100_appendix.Rmd-->

